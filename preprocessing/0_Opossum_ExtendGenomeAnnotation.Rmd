---
title: "Opossum Genome 3' Extension"
output: 
---

```{r setup, include=FALSE}
# This sets the project root based on the repo structure.
# If you move this file, you may to set the root manually to find config.R
knitr::opts_knit$set(root.dir = dirname(dirname(rstudioapi::getSourceEditorContext()$path)))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r libraries}
library(data.table)
library(stringr)
source("config.R")
```

```{r functions}
# Helpers
attr_get <- function(x, key) {
  m <- str_match(x, paste0(key, " \"([^\"]+)\""))
  m[, 2]
}

norm_biotype <- function(bt) {
  bt <- ifelse(is.na(bt), "other", bt)
  bt <- ifelse(bt %in% c("lincRNA"), "lncRNA", bt)
  bt <- ifelse(bt %in% c("protein_coding", "lncRNA"), bt, "other")
  bt
}

read_gtf_9col <- function(gtf_path) {
  lines <- readLines(gtf_path, warn = FALSE)
  lines <- lines[!grepl("^#", lines)]
  lines <- lines[nzchar(lines)]

  dt <- fread(
    text = lines,
    sep = "\t",
    header = FALSE,
    fill = TRUE,
    quote = "",
    data.table = TRUE,
    showProgress = FALSE
  )

  if (ncol(dt) < 9) stop("GTF parse failed: expected >=9 columns but got ", ncol(dt))

  dt <- dt[, 1:9, with = FALSE]
  setnames(dt, paste0("V", 1:9))
  dt
}

read_fai_lengths <- function(fai_path) {
  # FAI format: name length offset linebases linewidth
  ctg <- fread(
    fai_path,
    sep = "\t",
    header = FALSE,
    data.table = TRUE,
    showProgress = FALSE
  )
  if (ncol(ctg) < 2) stop("FAI parse failed: expected >=2 columns but got ", ncol(ctg))
  ctg <- ctg[, .(seqname = V1, ctg_len = as.integer(V2))]
  setkey(ctg, seqname)
  ctg
}

# Main

extend_gtf_3prime <- function(
  gtf_in,
  gtf_out,
  extend_by_bp = 5000L,
  extend_if_gap_gt_bp = 10000L,
  use_neighbor_any_strand = TRUE,
  biotypes_keep = c("protein_coding", "lncRNA"),
  fasta_fai = NULL                 # FAI file for contig-bound capping
) {
  gtf <- read_gtf_9col(gtf_in)

  # If fasta_fai not provided, assume it's in the same directory as the GTF
  if (is.null(fasta_fai)) {
    fasta_fai <- file.path(dirname(gtf_in), "Monodelphis_domestica.ASM229v1.dna.toplevel.fa.fai")
  }
  if (!file.exists(fasta_fai)) {
    stop("FAI file not found: ", fasta_fai, "\nProvide fasta_fai=... or place it next to the GTF.")
  }
  ctg <- read_fai_lengths(fasta_fai)

  gtf[, gene_id := attr_get(V9, "gene_id")]
  gtf[, transcript_id := attr_get(V9, "transcript_id")]
  gtf[, gene_biotype := attr_get(V9, "gene_biotype")]
  gtf[is.na(gene_biotype), gene_biotype := attr_get(V9, "gene_type")]
  gtf[, gene_biotype := norm_biotype(gene_biotype)]

  genes <- gtf[V3 == "gene" & !is.na(gene_id),
               .(seqname = V1, source = V2, start = as.integer(V4), end = as.integer(V5),
                 strand = V7, gene_id, gene_biotype)]
  genes <- genes[gene_biotype %in% biotypes_keep]
  if (nrow(genes) == 0) stop("No genes after filtering biotype")

  genes_all <- gtf[V3 == "gene" & !is.na(gene_id),
                   .(seqname = V1, start = as.integer(V4), end = as.integer(V5), strand = V7, gene_id)]
  setorder(genes_all, seqname, start, end)

  if (!use_neighbor_any_strand) {
    genes_all <- genes_all[, .SD, by = .(seqname, strand)]
    setorder(genes_all, seqname, strand, start, end)
  }

  if (use_neighbor_any_strand) {
    genes_all[, next_start := shift(start, type = "lead"), by = seqname]
    genes_all[, prev_end   := shift(end,   type = "lag"),  by = seqname]
  } else {
    genes_all[, next_start := shift(start, type = "lead"), by = .(seqname, strand)]
    genes_all[, prev_end   := shift(end,   type = "lag"),  by = .(seqname, strand)]
  }

  neighbor <- genes_all[, .(seqname, strand, gene_id, start, end, next_start, prev_end)]
  genes2 <- merge(genes, neighbor, by = c("seqname","strand","gene_id","start","end"), all.x = TRUE)

  # Strand-aware downstream gap
  genes2[, gap_bp := NA_integer_]
  genes2[strand == "+", gap_bp := as.integer(next_start - end)]
  genes2[strand == "-", gap_bp := as.integer(start - prev_end)]
  genes2[is.na(gap_bp), gap_bp := as.integer(.Machine$integer.max)]

  # Decide extension: only if gap > threshold; cap to min(extend_by, gap-1)
  genes2[, extend_bp := 0L]
  genes2[gap_bp > extend_if_gap_gt_bp,
         extend_bp := pmin(as.integer(extend_by_bp), pmax(0L, gap_bp - 1L))]
  genes2[extend_bp < 0L, extend_bp := 0L]

  # Apply extension to gene coordinates (store old boundary too)
  genes2[, `:=`(old_start = start, old_end = end)]
  genes2[strand == "+", end := end + extend_bp]
  genes2[strand == "-", start := pmax(1L, start - extend_bp)]

  # Cap to contig bounds via FAI, then recompute actual extend_bp
  genes2 <- merge(genes2, ctg, by = "seqname", all.x = TRUE)

  # If contig length missing in FAI, revert extension
  genes2[is.na(ctg_len), `:=`(start = old_start, end = old_end, extend_bp = 0L)]

  # Clamp to [1, ctg_len]
  genes2[!is.na(ctg_len), start := pmax(1L, start)]
  genes2[!is.na(ctg_len), end   := pmin(ctg_len, end)]

  # Recompute achieved extension after clamping (3' only)
  genes2[, actual_extend_bp := 0L]
  genes2[strand == "+", actual_extend_bp := pmax(0L, end - old_end)]
  genes2[strand == "-", actual_extend_bp := pmax(0L, old_start - start)]
  genes2[, extend_bp := as.integer(actual_extend_bp)]
  genes2[, actual_extend_bp := NULL]
  genes2 <- genes2[start <= end]

  genes_mod <- genes2[extend_bp > 0L,
                      .(seqname, strand, gene_id, gene_biotype,
                        old_start, old_end, start, end, extend_bp)]
  message("Extending 3' ends for ", nrow(genes_mod), " genes")

  if (nrow(genes_mod) == 0) {
    fwrite(gtf[, .(V1,V2,V3,V4,V5,V6,V7,V8,V9)], gtf_out, sep = "\t", col.names = FALSE, quote = FALSE)
    return(invisible(NULL))
  }

  gtf_mod <- copy(gtf)

  bounds <- genes_mod[, .(
    gene_id,
    strand,
    old_start,
    old_end,
    new_start = start,
    new_end   = end,
    extend_bp
  )]
  setkey(bounds, gene_id)

  # Update gene rows (3' side only)
  idx_gene <- which(gtf_mod$V3 == "gene" & gtf_mod$gene_id %in% bounds$gene_id)
  if (length(idx_gene)) {
    tmp <- bounds[gtf_mod$gene_id[idx_gene]]
    gtf_mod$V4[idx_gene] <- ifelse(tmp$strand == "-", tmp$new_start, gtf_mod$V4[idx_gene])
    gtf_mod$V5[idx_gene] <- ifelse(tmp$strand == "+", tmp$new_end,   gtf_mod$V5[idx_gene])
  }

  # Update transcript rows at the 3' end only
  idx_tx <- which(gtf_mod$V3 == "transcript" & gtf_mod$gene_id %in% bounds$gene_id)
  if (length(idx_tx)) {
    tmp <- bounds[gtf_mod$gene_id[idx_tx]]
    gtf_mod$V5[idx_tx] <- ifelse(tmp$strand == "+",
                                 pmax(as.integer(gtf_mod$V5[idx_tx]), tmp$new_end),
                                 gtf_mod$V5[idx_tx])
    gtf_mod$V4[idx_tx] <- ifelse(tmp$strand == "-",
                                 pmin(as.integer(gtf_mod$V4[idx_tx]), tmp$new_start),
                                 gtf_mod$V4[idx_tx])
  }

  # ---- Add new 3'UTR + exon segments ----
  tx <- gtf_mod[V3 == "transcript" & gene_id %in% bounds$gene_id & !is.na(transcript_id),
                .(V1,V2,V3,V4 = as.integer(V4),V5 = as.integer(V5),V6,V7,V8,V9,gene_id,transcript_id)]
  if (nrow(tx)) {
    setkey(tx, gene_id)
    txb <- bounds[tx, nomatch = 0]  # adds old_start/old_end/new_start/new_end/extend_bp/strand

    txb <- txb[extend_bp > 0]
    if (nrow(txb)) {
      txb[strand == "+", `:=`(seg_start = old_end + 1L, seg_end = new_end)]
      txb[strand == "-", `:=`(seg_start = new_start,   seg_end = old_start - 1L)]
      txb <- txb[seg_end >= seg_start]

      make_feat <- function(df, feat) {
        df[, .(
          V1 = V1,
          V2 = V2,
          V3 = feat,
          V4 = as.integer(seg_start),
          V5 = as.integer(seg_end),
          V6 = V6,
          V7 = V7,
          V8 = V8,
          V9 = V9
        )]
      }

      new_utr  <- make_feat(txb, "three_prime_utr")
      new_exon <- make_feat(txb, "exon")

      gtf_mod <- rbindlist(
        list(gtf_mod[, .(V1,V2,V3,V4,V5,V6,V7,V8,V9)], new_utr, new_exon),
        use.names = TRUE,
        fill = TRUE
      )
    } else {
      gtf_mod <- gtf_mod[, .(V1,V2,V3,V4,V5,V6,V7,V8,V9)]
    }
  } else {
    gtf_mod <- gtf_mod[, .(V1,V2,V3,V4,V5,V6,V7,V8,V9)]
  }

  gtf_mod[, V4 := as.integer(V4)]
  gtf_mod[, V5 := as.integer(V5)]
  setorder(gtf_mod, V1, V4, V5)

  fwrite(gtf_mod, gtf_out, sep = "\t", col.names = FALSE, quote = FALSE)
  invisible(NULL)
}
```

```{r run_extension_3kb}
extend_gtf_3prime(
  gtf_in  = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.gtf"),
  gtf_out = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.lt10kb.ex3kb.gtf"),
  extend_by_bp = 3000L,
  extend_if_gap_gt_bp = 10000L,
  use_neighbor_any_strand = TRUE,
  biotypes_keep = c("protein_coding", "lncRNA")
)
```

```{r run_extension_5kb}
extend_gtf_3prime(
  gtf_in  = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.gtf"),
  gtf_out = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.lt10kb.ex5kb.gtf"),
  extend_by_bp = 5000L,
  extend_if_gap_gt_bp = 10000L,
  use_neighbor_any_strand = TRUE,
  biotypes_keep = c("protein_coding", "lncRNA")
)
```

```{r}
# ---- GTF postprocessor for SAW format (Stereo-seq) ----
# Enforces 9-column GTF with required attributes: gene_name, gene_id, transcript_name, transcript_id
# Sanitizes names, rescues orphan rows, drops extraneous tags, reorders for contiguity

suppressPackageStartupMessages({
  library(data.table)
  library(stringr)
})

read_gtf_9col <- function(gtf_path) {
  lines <- readLines(gtf_path, warn = FALSE)
  lines <- lines[!grepl("^#", lines)]
  lines <- lines[nzchar(lines)]

  dt <- fread(
    text = lines,
    sep = "\t",
    header = FALSE,
    fill = TRUE,
    quote = "",
    data.table = TRUE,
    showProgress = FALSE
  )
  if (ncol(dt) < 9) stop("GTF parse failed: expected >=9 columns but got ", ncol(dt))
  dt <- dt[, 1:9, with = FALSE]
  setnames(dt, paste0("V", 1:9))
  dt
}

# Extract all tag "value" pairs (keeps first occurrence per key)
parse_attrs <- function(attr_vec) {
  lapply(attr_vec, function(s) {
    if (is.na(s) || !nzchar(s)) return(setNames(character(), character()))
    m <- str_match_all(s, '([A-Za-z0-9_]+)\\s+"([^"]*)"')
    if (length(m) == 0 || nrow(m[[1]]) == 0) return(setNames(character(), character()))
    keys <- m[[1]][, 2]
    vals <- m[[1]][, 3]
    keep <- !duplicated(keys)
    out <- vals[keep]
    names(out) <- keys[keep]
    out
  })
}

sanitize_name <- function(x) {
  x <- ifelse(is.na(x), "", x)
  x <- gsub("[^A-Za-z0-9_.]", "_", x)
  x <- gsub("_+", "_", x)
  x <- gsub("^_+|_+$", "", x)
  ifelse(nchar(x) > 63, substr(x, 1, 63), x)
}

# ONLY keep the 4 SAW-required tags, in a fixed order (quoted)
rebuild_attrs_minimal <- function(gene_id, gene_name, transcript_id, transcript_name) {
  sprintf(
    'gene_id "%s"; gene_name "%s"; transcript_id "%s"; transcript_name "%s";',
    gene_id, gene_name, transcript_id, transcript_name
  )
}

make_saw_safe_gtf <- function(gtf_in, gtf_out) {
  gtf <- read_gtf_9col(gtf_in)

  # Parse attributes once
  attrs <- parse_attrs(gtf$V9)

  getk <- function(a, k) if (k %in% names(a)) a[[k]] else NA_character_

  gene_id <- vapply(attrs, getk, k = "gene_id", FUN.VALUE = character(1))
  if (any(is.na(gene_id) | gene_id == "")) {
    stop("Some rows lack gene_id in attributes; SAW requires gene_id everywhere.")
  }

  tx_id <- vapply(attrs, getk, k = "transcript_id", FUN.VALUE = character(1))
  tx_id[is.na(tx_id)] <- ""

  gene_name <- vapply(attrs, getk, k = "gene_name", FUN.VALUE = character(1))
  gene_name[is.na(gene_name) | gene_name == ""] <- gene_id[is.na(gene_name) | gene_name == ""]
  gene_name <- sanitize_name(gene_name)

  tx_name <- vapply(attrs, getk, k = "transcript_name", FUN.VALUE = character(1))
  miss_txn <- is.na(tx_name) | tx_name == ""
  tx_name[miss_txn] <- tx_id[miss_txn]
  tx_name[is.na(tx_name)] <- ""
  tx_name <- sanitize_name(tx_name)

  # Attach parsed fields for easy ops
  gtf[, gene_id := gene_id]
  gtf[, transcript_id := tx_id]
  gtf[, gene_name := gene_name]
  gtf[, transcript_name := tx_name]
  gtf[, start := as.integer(V4)]
  gtf[, end   := as.integer(V5)]

  # ---- Rescue orphan children ----
  # Orphan child = non-gene row with empty transcript_id
  orphan <- gtf[V3 != "gene" & (is.na(transcript_id) | transcript_id == ""),
                .(gene_id)]
  orphan_genes <- unique(orphan$gene_id)

  if (length(orphan_genes)) {
    # Choose a canonical transcript_id per gene if any transcript rows exist
    tx_map <- gtf[V3 == "transcript" & transcript_id != "",
                  .(canon_tx = transcript_id[1],
                    canon_tname = {
                      x <- transcript_name[1]
                      if (is.na(x) || x == "") transcript_id[1] else x
                    }),
                  by = gene_id]

    # Genes with orphan children but no transcript row -> fabricate a transcript
    need_synth <- setdiff(orphan_genes, tx_map$gene_id)
    if (length(need_synth)) {
      tx_map <- rbind(
        tx_map,
        data.table(
          gene_id = need_synth,
          canon_tx = paste0(need_synth, ".saw_tx1"),
          canon_tname = paste0(need_synth, ".saw_tx1")
        ),
        fill = TRUE
      )
    }
    setkey(tx_map, gene_id)

    # Assign orphan children to canon_tx
    idx_orphan <- which(gtf$V3 != "gene" & (is.na(gtf$transcript_id) | gtf$transcript_id == ""))
    if (length(idx_orphan)) {
      tmp <- tx_map[gtf$gene_id[idx_orphan]]
      gtf$transcript_id[idx_orphan] <- tmp$canon_tx
      gtf$transcript_name[idx_orphan] <- sanitize_name(tmp$canon_tname)
    }

    # Add synthetic transcript rows for genes that needed them
    synth_map <- tx_map[grepl("\\.saw_tx1$", canon_tx)]
    if (nrow(synth_map)) {
      # Use gene coordinates for transcript coords
      gene_rows <- gtf[V3 == "gene" & gene_id %in% synth_map$gene_id,
                       .(V1, V2, V6, V7, V8, gene_id, gene_name, start, end)]
      synth <- merge(gene_rows, synth_map, by = "gene_id", all.x = TRUE)

      synth_dt <- synth[, .(
        V1 = V1,
        V2 = V2,
        V3 = "transcript",
        V4 = as.character(start),
        V5 = as.character(end),
        V6 = V6,
        V7 = V7,
        V8 = V8,
        V9 = rebuild_attrs_minimal(
          gene_id,
          sanitize_name(gene_name),
          canon_tx,
          sanitize_name(canon_tname)
        )
      )]

      gtf <- rbindlist(
        list(
          gtf[, .(V1,V2,V3,V4,V5,V6,V7,V8,V9,gene_id,transcript_id,gene_name,transcript_name,start,end)],
          synth_dt[, `:=`(
            gene_id = attr_get(V9, "gene_id"),
            transcript_id = attr_get(V9, "transcript_id"),
            gene_name = attr_get(V9, "gene_name"),
            transcript_name = attr_get(V9, "transcript_name"),
            start = as.integer(V4),
            end = as.integer(V5)
          )]
        ),
        use.names = TRUE,
        fill = TRUE
      )
    }
  }

  # ---- Drop extraneous tags, keep only 4 required ----
  gtf[, gene_name := sanitize_name(gene_name)]
  gtf[, transcript_name := sanitize_name(transcript_name)]
  gtf[V3 == "gene", `:=`(transcript_id = "", transcript_name = "")]  # gene rows can be empty

  gtf[, V9 := rebuild_attrs_minimal(gene_id, gene_name, transcript_id, transcript_name)]

  # ---- Reorder rows: contiguous by gene ----
  gene_rows <- gtf[V3 == "gene", .(seqname = V1, gstart = start, gend = end, gene_id)]
  if (nrow(gene_rows) == 0) stop("No 'gene' features found; SAW requires them.")
  setorder(gene_rows, seqname, gstart, gend, gene_id)
  gene_rows[, gene_rank := .I]
  setkey(gene_rows, gene_id)

  gtf <- gene_rows[gtf, on = "gene_id"]
  gtf <- gtf[!is.na(gene_rank)]  # drop rows whose gene row is missing

  tx_rows <- gtf[V3 == "transcript" & transcript_id != "",
                 .(gene_id, transcript_id, tstart = start, tend = end)]
  if (nrow(tx_rows)) {
    setorder(tx_rows, gene_id, tstart, tend, transcript_id)
    tx_rows[, tx_rank := seq_len(.N), by = gene_id]
    setkey(tx_rows, gene_id, transcript_id)
    gtf <- tx_rows[gtf, on = .(gene_id, transcript_id)]
  } else {
    gtf[, tx_rank := NA_integer_]
  }
  gtf[is.na(tx_rank), tx_rank := 999999L]

    # Feature rank: gene first, transcript second, everything else third
  gtf[, feature_rank := fifelse(V3 == "gene", 1L,
                                fifelse(V3 == "transcript", 2L, 3L))]

  # Put gene row first inside each gene block no matter what
  gtf[V3 == "gene", tx_rank := -1L]

  # Child rows without transcript_id were assigned a transcript_id in rescue,
  # but keep any remaining NA ranks safely at the end.
  gtf[is.na(tx_rank), tx_rank := 999999L]

  # FINAL SAW ordering
  setorder(gtf, gene_rank, feature_rank, tx_rank, start, end, V3)

  # Write out 9 columns only (keep original V4/V5 as integers-as-strings)
  out <- gtf[, .(
    V1, V2, V3,
    V4 = as.character(start),
    V5 = as.character(end),
    V6, V7, V8, V9
  )]

  fwrite(out, gtf_out, sep = "\t", col.names = FALSE, quote = FALSE)
  invisible(gtf_out)
}
```

```{r}
make_saw_safe_gtf(
  gtf_in  = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.lt10kb.ex5kb.gtf"),
  gtf_out = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.lt10kb.ex5kb.SAW.gtf")
)
```

```{r}
# ---- SAW GTF edge-case checker ----
# Flags issues likely to break Stereo-seq SAW:
#  - not 9 columns / non-integer coords / start>end / out-of-range
#  - strand not +/-
#  - missing required feature types (gene/transcript/exon)
#  - attributes not in tag "value"; form (detects any unquoted token=value etc.)
#  - missing required tags: gene_id, gene_name, transcript_id, transcript_name
#  - gene_name/transcript_name illegal chars or length >=64
#  - ordering violations: exon before transcript, transcript before gene, gene blocks not contiguous
#  - gene_id duplicates across non-contiguous blocks
#
# Output:
#  - list(errors=..., warnings=..., summary=...)
#  - also writes TSVs if out_prefix provided

read_gtf_9col_raw <- function(gtf_path) {
  lines <- readLines(gtf_path, warn = FALSE)
  lines <- lines[nzchar(lines)]
  # keep comments for counting; drop them for parsing
  body <- lines[!grepl("^#", lines)]

  dt <- fread(
    text = body,
    sep = "\t",
    header = FALSE,
    fill = TRUE,
    quote = "",
    data.table = TRUE,
    showProgress = FALSE
  )
  if (ncol(dt) < 9) stop("Parse failed: expected >=9 columns but got ", ncol(dt))
  dt <- dt[, 1:9, with = FALSE]
  setnames(dt, paste0("V", 1:9))
  dt
}

attr_get <- function(x, key) {
  m <- str_match(x, paste0(key, ' "([^"]*)"'))
  m[, 2]
}

has_quoted_pairs_only <- function(attr) {
  # Remove all valid pairs: key "value";
  stripped <- gsub('[A-Za-z0-9_]+\\s+"[^"]*"\\s*;?', "", attr)
  # Remove whitespace and stray semicolons
  stripped <- gsub("[[:space:];]+", "", stripped)
  # If anything remains, it's nonconforming (e.g., ID=, unquoted, weird tokens)
  stripped == ""
}

illegal_name_chars <- function(x) {
  # SAW disallows: space, all brackets, quotes, <>, %, etc.
  # Allow only letters/numbers/underscore/dot (conservative).
  grepl("[^A-Za-z0-9_.]", x)
}

check_saw_gtf <- function(gtf_path, fasta_fai = NULL, out_prefix = NULL, max_gene_count = 1048576L) {
  dt <- read_gtf_9col_raw(gtf_path)

  dt[, line := .I]
  dt[, start := suppressWarnings(as.integer(V4))]
  dt[, end   := suppressWarnings(as.integer(V5))]
  dt[, strand := V7]
  dt[, feature := V3]
  dt[, seqname := V1]
  dt[, attrs := V9]

  dt[, gene_id := attr_get(attrs, "gene_id")]
  dt[, gene_name := attr_get(attrs, "gene_name")]
  dt[, transcript_id := attr_get(attrs, "transcript_id")]
  dt[, transcript_name := attr_get(attrs, "transcript_name")]

  errors <- list()
  warnings <- list()

  errors[["bad_start_end_parse"]] <- dt[is.na(start) | is.na(end), .(line, seqname, feature, V4, V5)]
  errors[["start_gt_end"]] <- dt[!is.na(start) & !is.na(end) & start > end, .(line, seqname, feature, start, end)]
  errors[["coord_out_of_range"]] <- dt[!is.na(start) & (start <= 0L | start >= 2^31) |
                                       !is.na(end)   & (end   <= 0L | end   >= 2^31),
                                       .(line, seqname, feature, start, end)]
  errors[["bad_strand"]] <- dt[!(strand %in% c("+", "-")), .(line, seqname, feature, strand)]

  present_types <- unique(dt$feature)
  miss_types <- setdiff(c("gene", "transcript", "exon"), present_types)
  if (length(miss_types)) errors[["missing_feature_types"]] <- data.table(missing = miss_types)

  warnings[["non_gtf_attribute_tokens"]] <- dt[nzchar(attrs) & !has_quoted_pairs_only(attrs),
                                               .(line, seqname, feature, attrs)]

  errors[["missing_gene_id"]] <- dt[is.na(gene_id) | gene_id == "", .(line, seqname, feature, attrs)]
  errors[["missing_gene_name"]] <- dt[is.na(gene_name) | gene_name == "", .(line, seqname, feature, gene_id, attrs)]
  errors[["missing_transcript_id_non_gene"]] <- dt[feature != "gene" & (is.na(transcript_id) | transcript_id == ""),
                                                   .(line, seqname, feature, gene_id, attrs)]
  errors[["missing_transcript_name_non_gene"]] <- dt[feature != "gene" & (is.na(transcript_name) | transcript_name == ""),
                                                     .(line, seqname, feature, gene_id, transcript_id, attrs)]

  errors[["gene_name_illegal_chars"]] <- dt[!is.na(gene_name) & gene_name != "" & illegal_name_chars(gene_name),
                                            .(line, gene_id, gene_name)]
  errors[["transcript_name_illegal_chars"]] <- dt[!is.na(transcript_name) & transcript_name != "" & illegal_name_chars(transcript_name),
                                                  .(line, gene_id, transcript_id, transcript_name)]
  errors[["gene_name_too_long"]] <- dt[!is.na(gene_name) & nchar(gene_name) >= 64,
                                       .(line, gene_id, gene_name, n = nchar(gene_name))]
  errors[["transcript_name_too_long"]] <- dt[!is.na(transcript_name) & nchar(transcript_name) >= 64,
                                             .(line, gene_id, transcript_id, transcript_name, n = nchar(transcript_name))]

  # ---- FASTA bounds check ----
  if (!is.null(fasta_fai)) {
    fai <- fread(fasta_fai, sep = "\t", header = FALSE, data.table = TRUE, showProgress = FALSE)
    if (ncol(fai) < 2) stop("FAI parse failed: expected >=2 cols")
    fai <- fai[, .(seqname = V1, ctg_len = as.integer(V2))]
    setkey(fai, seqname)

    dt2 <- fai[dt, on = "seqname"]  # keeps dt columns; adds ctg_len
    errors[["contig_missing_in_fasta"]] <- dt2[is.na(ctg_len), .(line, seqname, feature)]
    errors[["end_exceeds_contig"]] <- dt2[!is.na(ctg_len) & !is.na(end) & end > ctg_len,
                                          .(line, seqname, feature, start, end, ctg_len, gene_id)]
  }

  # ---- Ordering checks ----
  dt[, level := fifelse(feature == "gene", 1L, fifelse(feature == "transcript", 2L, 3L))]

  gene_first_line <- dt[feature == "gene" & !is.na(gene_id) & gene_id != "", .(gene_line = min(line)), by = gene_id]
  setkey(gene_first_line, gene_id)
  dtg <- gene_first_line[dt, on = "gene_id"]
  errors[["rows_before_gene"]] <- dtg[!is.na(gene_line) & line < gene_line, .(line, gene_line, gene_id, feature)]

  tx_first_line <- dt[feature == "transcript" & transcript_id != "", .(tx_line = min(line)), by = transcript_id]
  setkey(tx_first_line, transcript_id)
  dtt <- tx_first_line[dt, on = "transcript_id"]
  errors[["rows_before_transcript"]] <- dtt[feature != "gene" & transcript_id != "" & !is.na(tx_line) & line < tx_line,
                                            .(line, tx_line, gene_id, transcript_id, feature)]

  dtn <- dt[!is.na(gene_id) & gene_id != "", .(line, gene_id)]
  dtn[, run := rleid(gene_id)]
  segs <- dtn[, .(start_line = min(line), end_line = max(line)), by = .(gene_id, run)]
  noncontig <- segs[, .N, by = gene_id][N > 1]
  errors[["noncontiguous_gene_blocks"]] <- noncontig

  n_genes <- uniqueN(dt[feature == "gene" & !is.na(gene_id) & gene_id != "", gene_id])
  if (n_genes > max_gene_count) {
    errors[["gene_count_exceeds_limit"]] <- data.table(n_genes = n_genes, max_allowed = max_gene_count)
  }

  summary <- data.table(
    file = gtf_path,
    n_rows = nrow(dt),
    n_genes = n_genes,
    n_transcripts = uniqueN(dt[feature == "transcript" & transcript_id != "", transcript_id]),
    n_exons = sum(dt$feature == "exon"),
    n_errors = sum(vapply(errors, nrow, integer(1)) > 0),
    n_warnings = sum(vapply(warnings, nrow, integer(1)) > 0)
  )

  if (!is.null(out_prefix)) {
    for (nm in names(errors)) if (nrow(errors[[nm]]) > 0) fwrite(errors[[nm]], paste0(out_prefix, ".", nm, ".ERROR.tsv"), sep = "\t")
    for (nm in names(warnings)) if (nrow(warnings[[nm]]) > 0) fwrite(warnings[[nm]], paste0(out_prefix, ".", nm, ".WARN.tsv"), sep = "\t")
    fwrite(summary, paste0(out_prefix, ".summary.tsv"), sep = "\t")
  }

  list(errors = errors, warnings = warnings, summary = summary)
}
```

```{r}
res <- check_saw_gtf(
  gtf_path  = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.110.filtered.lt10kb.ex5kb.SAW.gtf"),
  fasta_fai = paste0(dir.list$central, "/genome/", "Monodelphis_domestica.ASM229v1.dna.toplevel.fa.fai"),
  out_prefix = paste0(dir.list$central, "/genome/", "check_opossum_ex5kb_SAW")
)
print(res$summary)
# Show top offenders for a category:
head(res$errors$end_exceeds_contig)
```
